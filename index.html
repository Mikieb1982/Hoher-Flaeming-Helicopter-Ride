index.html
directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // --- Helicopter Model ---
            helicopter = new THREE.Group();
            // Body
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.4 });
            const bodyGeometry = new THREE.BoxGeometry(5, 2, 2);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            helicopter.add(body);
            // Cockpit
            const cockpitMaterial = new THREE.MeshStandardMaterial({ color: 0x6a8191, transparent: true, opacity: 0.6 });
            const cockpitGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(2.5, 0.2, 0);
            helicopter.add(cockpit);
            // Tail
            const tailGeometry = new THREE.BoxGeometry(4, 0.5, 0.5);
            const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
            tail.position.set(-4, 0.5, 0);
            helicopter.add(tail);
            // Rotor
            const rotorMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const rotorGeometry = new THREE.BoxGeometry(0.2, 8, 0.2);
            const rotor = new THREE.Mesh(rotorGeometry, rotorMaterial);
            rotor.position.y = 1.5;
            helicopter.add(rotor);
            
            helicopter.position.set(0, 150, 0); // Start higher up
            scene.add(helicopter);

            // --- Ground Plane with Hills and Curve ---
            createCurvedHillyTerrain();

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', (event) => keys[event.key.toLowerCase()] = true);
            document.addEventListener('keyup', (event) => keys[event.key.toLowerCase()] = false);

            // Start the animation loop
            animate();
        }

        function createCurvedHillyTerrain() {
            // Use a larger plane with more segments for detailed terrain
            const groundGeometry = new THREE.PlaneGeometry(20000, 20000, 256, 256);
            
            // Use a material that reacts to light to show the terrain shape
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3c692f, // A more natural, darker green
                wireframe: false 
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.receiveShadow = true;

            // === START OF TERRAIN GENERATION LOGIC (CORRECTED) ===
            const simplex = new SimplexNoise();
            const positions = ground.geometry.attributes.position;

            // --- Tweak these values to change the terrain ---
            const hillHeight = 350;      // Maximum height of the hills
            const hillFrequency = 0.0003;  // How close together hills are (smaller number = more spread out)
            const curveStrength = 0.000005; // How much the world curves (a very small value for a subtle effect)
            // ---------------------------------------------

            for (let i = 0; i < positions.count; i++) {
                // A PlaneGeometry is created in the XY plane.
                // We will rotate it to lie flat on the XZ plane.
                // So, the original vertex 'x' becomes the world 'x'.
                // The original vertex 'y' becomes the world 'z'.
                // The original vertex 'z' (which is 0) will be modified to become the world 'y' (height).
                const x = positions.getX(i);
                const y_as_z = positions.getY(i); // This vertex y will be our world z coordinate

                // 1. Generate Hills using Simplex Noise
                const noiseVal = simplex.noise2D(x * hillFrequency, y_as_z * hillFrequency);
                const height = noiseVal * hillHeight;

                // 2. Apply Curvature
                // We create a parabolic curve that makes the terrain drop off as it gets further away.
                const curve = y_as_z * y_as_z * curveStrength;

                // Apply the calculated height and curve to the Z-coordinate of the vertex.
                // After rotation, this z-coordinate will point "up" in the world (the Y-axis).
                positions.setZ(i, height - curve);
            }

            // Rotate the plane to be flat on the ground (XZ plane)
            ground.rotation.x = -Math.PI / 2;

            // Important: Tell Three.js that we've changed the geometry's vertices
            ground.geometry.attributes.position.needsUpdate = true;
            // Recalculate the normals so the lighting looks correct on the new terrain shape
            ground.geometry.computeVertexNormals();
            // === END OF TERRAIN GENERATION LOGIC ===

            scene.add(ground);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateHelicopter(deltaTime) {
            const forward = new THREE.Vector3();
            helicopter.getWorldDirection(forward);

            // Movement
            if (keys['w']) { // Forward
                velocity.add(forward.multiplyScalar(helicopterSpeed * deltaTime));
            }
            if (keys['s']) { // Backward
                velocity.add(forward.multiplyScalar(-helicopterSpeed * deltaTime));
            }
            if (keys['a']) { // Turn left
                helicopter.rotation.y += helicopterTurnSpeed;
            }
            if (keys['d']) { // Turn right
                helicopter.rotation.y -= helicopterTurnSpeed;
            }
            if (keys[' ']) { // Ascend
                velocity.y += helicopterHoverSpeed * deltaTime;
            }
            if (keys['shift']) { // Descend
                velocity.y -= helicopterHoverSpeed * deltaTime;
            }

            // Apply friction/drag
            velocity.multiplyScalar(0.98);

            // Update position
            helicopter.position.add(velocity);

            // Keep helicopter above a minimum altitude to prevent going underground
            if (helicopter.position.y < 5) {
                helicopter.position.y = 5;
                velocity.y = 0;
            }

            // Update camera to follow helicopter
            const cameraOffset = new THREE.Vector3(0, 5, -15); // Behind and slightly above
            const cameraPosition = cameraOffset.applyMatrix4(helicopter.matrixWorld);
            camera.position.lerp(cameraPosition, 0.1);
            camera.lookAt(helicopter.position);

            // Animate rotor
            helicopter.children[3].rotation.y += 0.5;

            // Update info panel
            const altitude = helicopter.position.y.toFixed(0);
            const speed = (velocity.length() * 100).toFixed(0); // Rough speed calculation
            infoPanel.innerHTML = `Altitude: ${altitude} m<br>Speed: ${speed} km/h`;
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            updateHelicopter(deltaTime);
            renderer.render(scene, camera);
        }

        // --- Start the application ---
        init();
    </script>
</body>
</html>

The main fix was to change which vertex coordinates were used for the noise calculation and which were modified for the height. I also moved the ground.rotation.x call to after the vertex manipulation to make the logic clearer.
This should now give you the rolling, curved landscape you were looking for. Please give it a try and let me know how it goes.
